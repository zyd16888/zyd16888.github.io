<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>操作系统</title>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        <link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
    </head>
    <body class="vscode-light">
        <h2 id="%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f">操作系统</h2>
<h3 id="%e5%9f%ba%e7%a1%80">基础</h3>
<ul>
<li>★★★ 进程与线程的本质区别、以及各自的使用场景</li>
</ul>
<ol>
<li>进程是资源分配的基本单位，线程是调度的基本单位。</li>
<li>同一进程的线程，对共享，栈私有，共享地址空间。</li>
<li>线程间可以直接通信，进程间需要经过IPC。</li>
<li>多进程：编程容易，不用考虑锁和同步资源问题，容错性强，数据隔离</li>
<li>多线程：创建快，数据共享，切换快，非均质服务</li>
</ol>
<ul>
<li>★★★ 进程调度算法的特点以及使用场景</li>
</ul>
<ol>
<li>FCFS（先来先服务）：有利于长作业，不利于短作业，非抢占</li>
<li>SJF（短作业优先）：估计最短运行时间调度，长作业可能会被饿死，非抢占</li>
<li>SRTN（最短剩余时间优先）：最短作业优先的抢占式，按剩余运行时间调度</li>
</ol>
<ul>
<li>★★★ 进程通信方法的特点以及使用场景★</li>
</ul>
<ol>
<li>管道（无名管道）：半双工，父子、兄弟进程间使用，pipe()</li>
<li>FIFO（命名管道、有名管道）：客户服务器间应用，fifo()</li>
<li>消息队列：独立于读写进程、避免了同步阻塞、有选择性接受</li>
<li>信号量：控制多进程访问共享数据</li>
<li>共享存储：速度最快</li>
<li>套接字：不同机器间进程通信</li>
</ol>
<ul>
<li>★★★ 死锁问题</li>
</ul>
<p>原因：系统资源不足、进程运行推进的顺序不合适、资源分配不当等</p>
<ol>
<li>必要条件：互斥、请求保持、不可抢占、环路等待</li>
<li>检测：- 每种类型一个资源：对访问过的节点进行标记 - 每种类型多个资源：资源总量进行计算</li>
<li>解决：剥夺资源、撤销进程、利用抢占、回滚、杀死进程恢复</li>
<li>预防：破坏四个必要条件</li>
<li>避免：安全状态检测、银行家算法</li>
</ol>
<p>数据库中解决死锁：</p>
<ol>
<li>按同一顺序访问对象。</li>
<li>避免事务中的用户交互。</li>
<li>保持事务简短并在一个批处理中。</li>
<li>使用低隔离级别。</li>
<li>使用绑定连接。</li>
<li>用存储过程查出引起死锁的进程和SQL语句。</li>
</ol>
<ul>
<li>★★★ 虚拟内存的作用，分页系统实现虚拟内存原理</li>
</ul>
<ol>
<li>让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存</li>
<li>分页地址映射、内存管理单元（MMU）</li>
<li>虚拟地址：页面号、偏移量</li>
</ol>
<ul>
<li>★★★ 页面置换算法的原理</li>
</ul>
<ol>
<li>最近最久未使用（LRU）非常重要</li>
<li>最近未使用（NRU）：使用链表实现，在Redis上作为缓存置换算法</li>
<li>先进先出（FIFO）</li>
<li>第二次机会：读写时R = 1，替换时R若为1，则改为0放在尾端，不换出</li>
<li>时钟</li>
</ol>
<ul>
<li>★★★ 比较分页与分段的区别</li>
</ul>
<ol>
<li>分页透明、分段需要程序员划分</li>
<li>分页为一维地址空间、分段为二维</li>
<li>页大小不变、段大小可变</li>
<li>分页：虚拟内存，分段：程序和数据在逻辑上独立、有利于共享和保护</li>
</ol>
<ul>
<li>★★★ 分析静态链接的不足，以及动态链接的特点★</li>
</ul>
<ol>
<li>不足：静态库更新时那么整个程序都要重新进行链接，对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源</li>
<li>动态：给定的文件系统中一个库只有一个文件，一个副本可以被不同的正在运行的进程共享</li>
</ol>
<ul>
<li>★★☆ 常见进程同步问题★</li>
</ul>
<ol>
<li>哲学家进餐</li>
<li>读者-写者</li>
</ol>
<ul>
<li>★★☆ 协程的作用</li>
</ul>
<ol>
<li>协程是单进程单线程的超越函数的调度机制，它通过一定的调度手段进行调度</li>
<li>可重入能力，类似与函数</li>
<li>用来控制过程输出状态的那些输入状态的管理工作</li>
</ol>
<ul>
<li>
<p>协程的优势，协程的轻量性体现在哪里？</p>
<ul>
<li>用户自己控制切换时机，不需要陷入内核态</li>
<li>没有线程切换的开销</li>
<li>不需要多线程锁机制，只要一个线程</li>
</ul>
</li>
<li>
<p>线程与堆栈的关系</p>
<ul>
<li>栈是线程私有的（局部变量、操作数、动态链接）</li>
<li>堆是线程共享的（对象的实例和数组）</li>
<li>方法区也是线程共享的</li>
</ul>
</li>
<li>
<p>★☆☆ 进程状态</p>
<ul>
<li>就绪：经调度算法可以转为运行</li>
<li>运行：cpu时间片用完后转为就绪</li>
<li>阻塞：缺少资源</li>
</ul>
</li>
<li>
<p>★☆☆ 线程实现的方式（Java），优劣</p>
<ul>
<li>继承Thread类，并重写其run()方法</li>
<li>实现Runnable接口，并实现其run()方法</li>
<li>实现Callable接口，并实现其call()方法</li>
<li>实现接口会更好一些：Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口</li>
</ul>
</li>
</ul>
<h3 id="linux">Linux</h3>
<ul>
<li>★★★ 硬链接与软链接的区别</li>
</ul>
<ol>
<li>硬链接：文件1 和 文件2 直接指向内存 <code>ln file1 file2</code></li>
<li>软链接：指向另外一个文件 <code>ln -s file1 file2</code></li>
</ol>
<ul>
<li>★★★ 僵尸进程与孤儿进程的区别，从 SIGCHLD 分析产生僵尸进程的原因</li>
</ul>
<ol>
<li>僵尸进程：子进程退出后，父进程未调用wait()waitpid()，进程描述符未释放</li>
<li>孤儿进程：父进程退出，子进程运行，会被init进程收养，没有危害</li>
<li>杀死僵尸进程的父进程，僵尸进程变为孤儿进程</li>
</ol>
<ul>
<li>★★☆ 文件系统的原理，特别是 inode 和 block。数据恢复原理</li>
</ul>
<ol>
<li>inode：一个文件占用一个 inode，记录文件的属性，同时记录此文件的内容所在的 block 编号；</li>
<li>block：记录文件的内容，文件太大时，会占用多个 block</li>
<li>superblock：记录文件系统的整体信息，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等</li>
<li>block bitmap：记录 block 是否被使用的位图</li>
</ol>
<ul>
<li>Linux启动时调用那些文件★</li>
</ul>
<ol>
<li>开启电源 --&gt; BIOS开机自检 --&gt; 引导程序lilo或grub --&gt; 内核的引导（kernel boot）--&gt; 执行init（rc.sysinit、rc）--&gt; mingetty(建立终端) --&gt; shell</li>
<li>/etc/profile --&gt; ~/.bash_profile --&gt; ~/.bash_login --&gt; ~/.profile</li>
</ol>
<ul>
<li>
<p>什么是linux的daemon进程？和一般进程有什么区别？</p>
<ul>
<li>守护进程，随系统启动和关闭，不与客户端交互，独立于终端。</li>
<li>使用ps axj命令查看进程时，其终端名(TTY)显示为？，ID显示为-1</li>
</ul>
</li>
<li>
<p>通过free命令查看内存时，看到的buffer和cache各表示什么含义？</p>
<ul>
<li>使用内存、剩余内存</li>
<li>Cache：缓存区，是高速缓存，是文件系统的cache</li>
<li>Buffer：缓冲区，传输数据，是块设备的读写缓冲区</li>
</ul>
</li>
<li>
<p>apache和nginx这两个web服务器有哪些区别？</p>
<ul>
<li>apache 是同步多进程模型，一个连接对应一个进程，而 nginx 是异步的，多个连接（万级别）可以对应一个进程</li>
<li>nginx轻量级，处理静态文件好，</li>
<li>apache 稳定，处理动态请求有优势</li>
</ul>
</li>
</ul>
<h2 id="%e7%bd%91%e7%bb%9c">网络</h2>
<h3 id="%e5%9f%ba%e7%a1%80-1">基础</h3>
<ul>
<li>★★★ <strong>各层的作用，TCP/IP 协议的特点</strong></li>
</ul>
<ol>
<li>
<p>应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。</p>
</li>
<li>
<p>传输层 ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</p>
</li>
<li>
<p>网络层 ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</p>
</li>
<li>
<p>数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</p>
</li>
<li>
<p>物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异</p>
</li>
<li>
<p>表示层 ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</p>
</li>
<li>
<p>会话层 ：建立及管理会话。</p>
</li>
<li>
<p>TCP/IP ： 只有四层，数据链路层和物理层合并为网络接口层</p>
</li>
</ol>
<ul>
<li>
<p>★★★ <strong>三次握手以及四次挥手具体过程、原因、TIME_WAIT</strong></p>
</li>
<li>
<p>★★★ <strong>可靠传输原理，并设计可靠 UDP 协议</strong></p>
</li>
</ul>
<ol>
<li>TCP 可靠传输：超时重传</li>
<li>可靠 UDP 协议：应用层实现确认机制、重传机制、窗口确认机制：RUDP、RTP、UDT</li>
</ol>
<ul>
<li>★★★ <strong>UDP 与 TCP 比较，分析上层协议应该使用 UDP 还是 TCP</strong></li>
</ul>
<ol>
<li>UDP：无连接、尽最大可能交付、一对一、多对多、多对一</li>
<li>TCP：面向连接、可靠交付、全双工、流量拥塞控制、字节流、一对一、确认机制、重传机制、滑动窗口</li>
</ol>
<ul>
<li>
<p>★★☆ <strong>路由选择协议及特点</strong></p>
<ul>
<li>RIP：距离向量、15跳、固定时间交换路由表、3分钟超时</li>
<li>OSPF：开放最短路径优先、洪泛发送信息、链路状态发生变化时发送信息</li>
<li>BGP：比较好不是最佳，TCP，发言人制度</li>
</ul>
</li>
<li>
<p>★★☆ <strong>DNS 的端口号；TCP 还是 UDP；作为缓存、负载均衡</strong></p>
</li>
</ul>
<ol>
<li>端口：53，UDP</li>
<li>使用TCP的情况：数据大于512字节，区域传送</li>
</ol>
<ul>
<li>★★☆ <strong>TCP 拥塞控制、四种方法、理解具体原理</strong>★</li>
</ul>
<ol>
<li>慢开始，拥塞避免，快重传，快恢复</li>
<li>防止过多的数据注入到网络当中，这样可以使网络中的路由器或链路不致过载</li>
</ol>
<ul>
<li>
<p>★★☆ <strong>浏览器访问页面（输入网址后发生了什么）</strong></p>
<ul>
<li>DHCP配置主机信息（可略过）
<ul>
<li>DHCP 请求报文，UDP，255.255.255.255:67,0.0.0.0:68</li>
<li>DHCP 服务器: DHCP ACK 报文:IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码</li>
</ul>
</li>
<li>ARP 解析 MAC 地址(获取路由网关地址)</li>
<li>DNS解析域名</li>
<li>HTTP 请求页面</li>
</ul>
</li>
<li>
<p>★★☆ <strong>集线器、交换机、路由器的作用，以及所属的层次</strong></p>
<ul>
<li>集线器：物理层、比特</li>
<li>交换机：链路层、自学习、按mac地址存储转发</li>
<li>路由器：网络层、IP地址转发</li>
</ul>
</li>
<li>
<p>★★☆ <strong>以太网的特点，以及帧结构</strong></p>
<ul>
<li>星型结构</li>
<li>帧结构：目的地址、源地址、类型、IP数据报、FCS</li>
</ul>
</li>
</ul>
<h3 id="http">HTTP</h3>
<ul>
<li>
<p>★★★ GET 与 POST 比较：作用、参数、安全性、幂等性、可缓存</p>
<ul>
<li>POST 主要用来传输数据，而 GET 主要用来获取资源</li>
<li>GET参数：ASCII码</li>
<li>GET安全、幂等，POST不安全不幂等</li>
<li>GET、HEAD可缓存，PUT、DELETE、POST不可缓存</li>
</ul>
</li>
<li>
<p>★★★ Cookie 作用、安全性问题、和 Session 的比较</p>
<ul>
<li>保存状态信息（会话管理、行为跟踪），cookie最大4kb</li>
<li>作用域：默认为当前文档的主机</li>
<li>Cookie可利用Session存在服务器端</li>
<li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据</li>
</ul>
</li>
<li>
<p>★★★ 长连接与短连接原理以及使用场景，流水线</p>
<ul>
<li>长连接：建立一个TCP多次进行HTTP通信</li>
<li>流水线：同一条长连接上连续发出请求</li>
</ul>
</li>
<li>
<p>★★★ HTTP 存在的安全性问题，以及 HTTPs 的加密、认证和完整性保护作用</p>
<ul>
<li>明文进行通信，不验证身份，无法证明报文的完整性</li>
<li>使用了SSL隧道进行通信</li>
<li>使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key</li>
<li>获取到 Secret Key 后，再使用对称密钥加密方式进行通信</li>
<li>SSL 提供报文摘要功能来进行完整性保护、MD5</li>
</ul>
</li>
<li>
<p>★★☆ 缓存 的Cache-Control 字段、Expires 和 max-age 的区别、ETag 验证原理</p>
<ul>
<li>缓解服务器压力，降低客户端获取资源的延迟</li>
<li>no-store：禁止，no-cache：强制确认，private：私有，public：公共</li>
<li>ETag ： 资源唯一标识</li>
</ul>
</li>
<li>
<p>★★★ HTTP/1.1 的特性</p>
<ul>
<li>默认是长连接</li>
<li>支持流水线</li>
<li>支持同时打开多个 TCP 连接</li>
<li>支持虚拟主机</li>
<li>新增状态码 100：表示正常</li>
<li>支持分块传输编码</li>
<li>新增缓存处理指令 max-age</li>
</ul>
</li>
<li>
<p>★★☆ HTTP/1.x 的缺陷，以及 HTTP/2 的特点</p>
<ul>
<li>缺陷：多个连接才能实现并发和缩短延迟、不会压缩请求和响应首部浪费流量、没有优先级支持</li>
<li>二进制帧分层、服务端推送、首部压缩</li>
</ul>
</li>
<li>
<p>★★☆ HTTP 与 FTP 的比较</p>
</li>
<li>
<p>★☆☆ 状态码</p>
</li>
<li>
<p>http协议中的keeplive是做什么的？它的适应场景是什么？</p>
<ul>
<li>让多个http请求共享一个Tcp连接，避免每个http新建tcp连接</li>
<li>定时发送心跳包</li>
</ul>
</li>
<li>
<p>http请求有多少种？</p>
<ul>
<li>8种</li>
<li>opions：返回服务器针对特定资源所支持的HTML请求方法、get、post、put：向指定资源位置上上传其最新内容</li>
<li>head：查看某个页面的状态、delete、trace：回显服务器收到的请求、connect</li>
</ul>
</li>
<li>
<p>查看linux系统中tcp连接的状态和连接数量统计</p>
<ul>
<li><code>netstat -an | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'</code></li>
</ul>
</li>
<li>
<p>bash shell 里<code>$0.$?.$$</code>各表示什么含义</p>
<ul>
<li>$$ Shell本身的PID（ProcessID）</li>
<li>$! Shell最后运行的后台Process的PID</li>
<li>$? 最后运行的命令的结束代码（返回值）</li>
<li>$# 是传给脚本的参数个数</li>
<li>$0 是脚本本身的名字</li>
<li>$1 是传递给该shell脚本的第一个参数</li>
<li>$2 是传递给该shell脚本的第二个参数</li>
<li>$@ 是传给脚本的所有参数的列表</li>
</ul>
</li>
</ul>
<h3 id="socket">Socket</h3>
<ul>
<li>
<p>★★★ select、poll、epoll 的原理、比较、以及使用场景；epoll 的水平触发与边缘触发</p>
<ul>
<li>都是多路复用的具体实现</li>
<li>select 会修改描述符，而 poll 不会</li>
<li>select 的描述符类型使用数组实现</li>
<li>poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高</li>
<li>如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定</li>
<li>select 和 poll 速度都比较慢</li>
</ul>
</li>
<li>
<p>★★☆ 五种 IO 模型的特点以及比较</p>
<ul>
<li>阻塞式I/O：阻塞应用，内核缓存--&gt;应用缓存（数据复制），复制完返回</li>
<li>非阻塞式I/O：进程调用、返回错误码、继续执行、不断询问io（轮询），CPU利用率低</li>
<li>I/O复用：单进程处理多IO，无进程创建切换，系统开销小</li>
<li>信号驱动I/O：进程使用 sigaction 系统调用，内核立即返回，进程继续执行，数据到达时内核向应用发送 SIGIO 信号，进程调用 recvfrom 复制数据，CPU利用率高</li>
<li>异步I/O：进程执行 aio_read 系统调用会立即返回，进程继续执行，不被阻塞，内核在操作完成后向进程发送信号</li>
<li>比较
<ul>
<li>同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞</li>
<li>异步 I/O：第二阶段应用进程不会阻塞</li>
</ul>
</li>
</ul>
</li>
<li>
<p>多路复用</p>
</li>
<li>
<p>Java NIO</p>
</li>
</ul>
<h2 id="%e6%95%b0%e6%8d%ae%e5%ba%93">数据库</h2>
<h3 id="sql">SQL</h3>
<ul>
<li>
<p>★★☆ 手写 SQL 语句，特别是连接查询与分组查询</p>
</li>
<li>
<p>★★☆ 连接查询与子查询的比较</p>
</li>
<li>
<p>★★☆ drop、delete、truncate 比较</p>
<ul>
<li>作用
<ul>
<li>DELETE 删除表中 WHERE 语句指定的数据。</li>
<li>TRUNCATE 清空表，相当于删除表中的所有数据。</li>
<li>DROP 删除表结构</li>
</ul>
</li>
<li>事务
<ul>
<li>DELETE 会被放到日志中以便进行回滚；</li>
<li>TRUNCATE 和 DROP 立即生效，不会放到日志中，也就不支持回滚。</li>
</ul>
</li>
<li>删除空间
<ul>
<li>DELETE 不会减少表和索引占用的空间；</li>
<li>TRUNCATE 会将表和索引占用的空间恢复到初始值；</li>
<li>DROP 会将表和索引占用的空间释放。</li>
</ul>
</li>
<li>耗时
<ul>
<li>DELETE &lt; TRUNCATE &lt; DROP</li>
</ul>
</li>
</ul>
</li>
<li>
<p>★★☆ 视图的作用，以及何时能更新视图</p>
<ul>
<li>虚拟表</li>
<li>简化复杂操作、保证数据安全性</li>
<li>更改数据格式和表示</li>
</ul>
</li>
<li>
<p>★☆☆ 理解存储过程、触发器等作用</p>
<ul>
<li>存储过程可以看成是对一系列 SQL 操作的批处理
<ul>
<li>优点：封装、提高安全性，代码复用，高性能</li>
<li>赋值用 select into ，每次只能给一个变量赋值，不支持集合的操作</li>
</ul>
</li>
<li>触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDATE
<ul>
<li>必须指定在语句执行之前还是之后自动执行（前：BEFORE，后：AFTER）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="mysql">MySQL</h3>
<ol>
<li>MySQL主键
<ul>
<li>其值能唯一地标识表中的每一行</li>
</ul>
</li>
</ol>
<h2 id="%e5%85%b6%e4%bb%96">其他</h2>
<ul>
<li>new和malloc区别</li>
</ul>
<ol>
<li>malloc和new都是在堆上开辟内存的</li>
<li>malloc只负责开辟内存，没有初始化功能</li>
<li>new不但开辟内存，还可以进行初始化</li>
<li>malloc是函数，开辟内存需要传入字节数</li>
<li>malloc开辟内存失败返回NULL，new开辟内存失败抛出bad_alloc类型的异常</li>
<li>malloc开辟的内存永远是通过free来释放的；而new单个元素内存，用的是delete，如果new[]数组，用的是delete[]来释放内存</li>
<li>malloc开辟内存只有一种方式，而new有四种分别是普通的new（内存开辟失败抛出bad_alloc异常）, nothrow版本的new，const new以及定位new</li>
</ol>
<ul>
<li>闭包
<ul>
<li>闭包函数：声明一个在函数中的函数</li>
<li>内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。</li>
<li>特点：
<ul>
<li>外部函数访问内部变量成为可能</li>
<li>局部变量常驻内存</li>
<li>避免使用全局变量、防止全局变量污染</li>
<li>会造成内存泄漏</li>
</ul>
</li>
<li>每次外部函数执行的时候，外部函数的引用地址不同，都会重新创建一个新的地址</li>
</ul>
</li>
</ul>
<h2 id="python">python</h2>
<ul>
<li>如何在Python中实现多线程？</li>
</ul>
<ol>
<li>
<p>答： Python有一个multi-threading包，但是如果你想让multi-thread加速你的代码，那么使用它通常不是一个好主意。</p>
</li>
<li>
<p>Python有一个名为Global Interpreter Lock(GIL)的结构。 GIL确保只有一个“线程”可以在任何时候执行。一个线程获取GIL，做一点工作，然后将GIL传递到下一个线程。</p>
</li>
<li>
<p>这种情况很快发生，因此对于人眼看来，您的线程似乎并行执行，但它们实际上只是轮流使用相同的CPU核心。</p>
</li>
<li>
<p>所有这些GIL传递都增加了执行的开销。这意味着如果您想让代码运行得更快，那么使用线程包通常不是一个好主意。</p>
</li>
</ol>
<ul>
<li>这是什么意思： *args，**kwargs？我们为什么要用呢？</li>
</ul>
<p>我们用<code>*args</code>当我们不确定将多少个参数传递给函数时，或者我们是否要将存储的列表或参数元组传递给函数时。<code>**kwargs</code>当我们不知道将多少关键字参数传递给函数时，或者它可以用于将字典的值作为关键字参数传递时使用。标识符args和kwargs是一个约定，你也可以使用<code>*bob</code>和<code>**billy</code>，但这不是明智之举.</p>
<ul>
<li>
<p>计算出从你生日之日起到今天一共过了多少天？（python、go、shell均可）</p>
</li>
<li>
<p>逆序输出偶数的平方 [1,2,3,4,5,6,7,8,9]</p>
</li>
</ul>
<pre><code class="language-python"><div><span class="hljs-comment">#列表切片</span>
list[i:j]
list[i:j:<span class="hljs-number">2</span>] <span class="hljs-comment">#取i到j，步长为2</span>
<span class="hljs-comment">#取奇数位</span>
list[::<span class="hljs-number">2</span>]
<span class="hljs-comment">#取偶数位</span>
list[<span class="hljs-number">1</span>::<span class="hljs-number">2</span>]
</div></code></pre>
<h2 id="%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1">面向对象</h2>
<h3 id="%e6%80%9d%e6%83%b3">思想</h3>
<ol>
<li>★★★ 面向对象三大特性
<ul>
<li>继承：父类指向子类时为向上转型</li>
<li>封装：减少耦合、减轻维护负担、提高可重用性、减少重构风险</li>
<li>多态：编译时多态与运行时多态
<ul>
<li>运行时多态：继承、覆盖（重写）、向上转型</li>
</ul>
</li>
</ul>
</li>
<li>★☆☆ 设计原则
<ul>
<li>单一责任原则SRP</li>
<li>开放封闭原则OCP</li>
<li>李氏替换原则LSP</li>
<li>接口分离原则ISP</li>
<li>依赖倒置原则DIP</li>
</ul>
</li>
</ol>
<h3 id="%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f">设计模式</h3>
<h2 id="java">Java</h2>
<h3 id="%e5%9f%ba%e7%a1%80-2">基础</h3>
<ol>
<li>基本类型与包装类型
<ul>
<li>byte/8 char/16 short/16 int/32 float/32 double/64 long/64 boolean/~</li>
</ul>
</li>
<li>缓存池、new Integer(123) 与 Integer.valueOf(123) 的区别
<ul>
<li>Integer 缓存池的大小默认为 -128~127</li>
</ul>
</li>
<li>String不可变的原因、好处
<ul>
<li>final 声明、不可被继承</li>
<li>Java8 中使用 char 存储、Java9 后使用byte数组存储</li>
<li>可以缓存hash值、String Pool的需要、提高安全性（参数不变）、线程安全</li>
<li>注意：StringBuffer可变、线程安全，StringBuilder可变、线程不安全</li>
</ul>
</li>
<li>参数传递的方式、类型转换、switch
<ul>
<li>值传递、地址值</li>
<li>不能隐式向下转型、<code>+=</code> 或者 <code>++</code> 运算符会执行隐式类型转换</li>
<li>switch 不支持 long</li>
</ul>
</li>
<li>Java类的初始化顺序
<ul>
<li>静态成员和<code>static块</code> -&gt; 普通成员和非<code>static</code>块 -&gt; 构造函数</li>
<li>父类静态 -&gt; 子类静态 -&gt; 父类普通 -&gt; 父类构造 -&gt; 子类普通 -&gt; 子类构造</li>
</ul>
</li>
<li><code>equal()</code> 与 <code>==</code> 的区别
<ul>
<li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法</li>
<li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价</li>
</ul>
</li>
<li>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等</li>
<li>clone()、浅拷贝、深拷贝
<ul>
<li>clone() 是 Object 的 protected 方法、需要显式重写</li>
<li>浅拷贝对象和原始对象的引用类型引用同一个对象</li>
<li>深拷贝对象和原始对象的引用类型引用不同对象</li>
<li>clone替代：拷贝构造函数、拷贝工厂</li>
</ul>
</li>
<li>反射的优缺点
<ul>
<li>定义：允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性</li>
<li>优点：可扩展性、类浏览器和可视化开发环境、调试器和测试工具</li>
<li>缺点：性能开销高、安全限制、内部暴露</li>
</ul>
</li>
<li>Java与c++的区别
<ul>
<li>Java面向对象，c++兼容c、可以面向过程</li>
<li>Java跨平台</li>
<li>Java无指针、自动垃圾回收</li>
<li>Java不支持多重继承，c++可以</li>
<li>Java不支持操作符重载</li>
<li>c++可以使用goto</li>
</ul>
</li>
<li>泛形相关
<ul>
<li>允许在定义类、接口、方法时使用类型形参，在声明变量、创建对象、调用方法时再传入实际类型参数</li>
<li>好处：编译时检查类型安全、隐式强制转换</li>
<li>工作方式：通过类型擦除实现</li>
<li>限定通配符：<? extends T> <? super T> 非限定通配符：<?></li>
</ul>
</li>
</ol>
<h3 id="%e5%ae%b9%e5%99%a8%e9%9b%86%e5%90%88">容器（集合）</h3>
<ul>
<li><a href="https://www.jianshu.com/p/75adf47958a7">HashMap 相关面试题及其解答</a></li>
</ul>
<h3 id="%e5%b9%b6%e5%8f%91">并发</h3>

    </body>
    </html>